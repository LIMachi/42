/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hmartzol <hmartzol@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/11/05 18:55:03 by hmartzol          #+#    #+#             */
/*   Updated: 2016/11/13 01:26:55 by hmartzol         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <libft.h>
#include <libftx.h>
#include <stdio.h>

/*
int	main(void)
{
	int			iterations = 100;
	float		limit = (float)(1UL << 32UL);
	t_complex	z;
	t_complex	c;
	int			map[screen_size.x][screen_size.y];
	float		zoom = 38;
	t_complex	mice = {-0.63, 0};
	t_complex	screen_center = {screen_size.x / 2, screen_size.y / 2};
	t_complex	z0 = {0, 0};
	int			max_n;

	max_n = 0;
	for (int y = 0; y < screen_size.y; ++y)
		for (int x = 0; x < screen_size.x; ++x)
		{
			int n = -1;
			c = ft_complex_add(ft_complex_scale(ft_complex_substract((t_complex){x, y}, screen_center), 1 / zoom), mice);
			z = z0;
			while (z.r * z.r + z.i * z.i < limit && (++n < iterations - 1))
				z = ft_complex_add(ft_complex_square(z), c);
			map[x][y] = n;
			if (n > max_n)
				max_n = n;
		}
	for (int y = 0; y < screen_size.y; ++y)
		for (int x = 0; x < screen_size.x; ++x)
		//todo: use highest n to get color ratio or current n
			ft_pixel(x, y, (char)(map[x][y] + 27));
}
*/

typedef struct	s_fractol_data
{
	unsigned int	iterations;
	double			limit;
	double			zoom;
	t_complex		mice;
	t_complex		screen_center;
	t_complex		z0;
	unsigned int	**map;
}				t_fractol_data;

int		ftx_hsv(double hue, double saturation, double value)
{
	double	f;
	double	s;
	double	t;
	double	shue;
	int		out;

	while (hue >= 360.0)
		hue -= 360.0;
	while (hue < 0.0)
		hue += 360.0;
	shue = hue;
	while (shue >= 120.0)
		shue -= 120.0;
	value = 1.0 - value / 100.0;
	saturation = (saturation / 100.0) * value;
	f = ((shue) / 120.0) * saturation;
	s = (1.0 - (shue) / 120.0) * saturation;
	t = saturation;
	if (hue < 120.0)
		out = (int)(f * 255.0) << 16 | (int)(s * 255.0) << 8 | (int)(t * 255.0);
	else if (hue < 240.0)
		out = (int)(t * 255.0) << 16 | (int)(f * 255.0) << 8 | (int)(s * 255.0);
	else
		out = (int)(s * 255.0) << 16 | (int)(t * 255.0) << 8 | (int)(f * 255.0);
	return (out);
}

int		fill_fractol(t_window *win, t_image *img)
{
	int				x;
	int				y;
	unsigned int	in;
	unsigned int	max;
	t_complex		c;
	t_complex		z;
	t_fractol_data	*data;

	data = (t_fractol_data*)win->data;
	y = -1;
	max = 0;
	while (++y < img->size.y && (x = -1))
		while (++x < img->size.x)
		{
			in = 0;
			c = ft_complex_add(ft_complex_scale(ft_complex_substract((t_complex){x, y}, data->screen_center), 1 / data->zoom), data->mice);
			z = data->z0;
			while (z.r * z.r + z.i * z.i < data->limit && (++in < data->iterations))
				z = ft_complex_add(ft_complex_square(z), c);
			data->map[y][x] = in;
			if (in > max)
				max = in;
		}
	y = -1;
	while (++y < img->size.y && (x = -1))
		while (++x < img->size.x)
			ftx_putpixelimg(img, ft_point(x, y), ftx_hsv(((double)data->map[y][x] / (double)max) * 360.0, 50.0, 0.0));
	img->update = 1;
	return (0);
}

int		fill_info(t_window *win, t_image *img)
{
	t_fractol_data	*data;

	data = (t_fractol_data*)win->data;
	printf("zoom: %f, iterations: %i, limit: %f, mice press: %i\n", data->zoom, data->iterations, data->limit, ftx_is_button_press(MICE_LEFT));
//	ftx_clear_img(img);
//	ftx_print_nbr(img, ft_point(1, 1), WHITE, data->zoom);
//	ftx_print_nbr(img, ft_point(1, 11), WHITE, data->iterations);
//	ftx_print_nbr(img, ft_point(1, 21), WHITE, data->limit);
	img->update = 1;
	return (1);
}

int		update(void	*ptr)
{
	int				up;
	t_fractol_data	*data;
	t_point			tmp;

	up = 0;
	data = (t_fractol_data*)((t_window*)ptr)->data;
	if (ftx_is_button_press(KEY_Z))
	{
		if (ftx_is_button_press(KEY_PAD_PLUS) && (up = 1))
			data->zoom += 10;
		if (ftx_is_button_press(KEY_PAD_MINUS) && (data->zoom > 10) && (up = 1))
			data->zoom -= 10;
	}
	if (ftx_is_button_press(KEY_I))
	{
		if (ftx_is_button_press(KEY_PAD_PLUS) && (up = 1))
			data->iterations += 1;
		if (ftx_is_button_press(KEY_PAD_MINUS) && (data->iterations > 2) && (up = 1))
			data->iterations -= 1;
	}
	if (ftx_is_button_press(KEY_L))
	{
		if (ftx_is_button_press(KEY_PAD_PLUS) && (up = 1))
			data->limit += 10;
		if (ftx_is_button_press(KEY_PAD_MINUS) && (data->limit > 10) && (up = 1))
			data->limit -= 10;
	}
	if (ftx_is_button_press(MICE_LEFT) && (up = 1))
	{
		tmp = ftx_data(GDX_ACCES)->mice.pos;
		printf("thing\n");
		data->mice = ft_complex_add(ft_complex_scale(ft_complex_substract((t_complex){tmp.x, tmp.y}, data->screen_center), 1 / data->zoom), data->mice);
	}
	if (ftx_is_button_press(KEY_PAD_0) && (up = 1))
	{
		data->iterations = 50;
		data->limit = (double)(1UL << 4UL);
		data->zoom = 38;
		data->mice = ft_complex(-0.63, 0);
	}
	return (up);
}

void	fractol(void)
{
	t_fractol_data	data;
	t_window		*win;
	t_image			*info;

	if (ftx_init() == NULL)
		return ;
	if ((win = ftx_create_window("fractol", ft_point(1000, 1000), 60, &fill_fractol)) == NULL)
		return ;
	data.iterations = 50;
	data.limit = (double)(1UL << 4UL);
	data.zoom = 38;
	data.mice = ft_complex(-0.63, 0);
	data.screen_center = ft_complex((double)win->size.x / 2.0, (double)win->size.y / 2.0);
	data.z0 = ft_complex(0, 0);
	data.map = (unsigned int**)ft_taballoc(win->size.x, win->size.y, sizeof(unsigned int));
	win->up_func = &update;
	win->data = (void*)&data;
	info = ftx_new_image(ft_point(50, 30));
	info->fill_func = &fill_info;
	ftx_add_image(win, info, 1);
	ftx_start();
}

int		main(int argc, char **argv)
{
	if (argc < 2)
	{
		write(1, "Usage: ", 7);
		write(1, argv[0], ft_strlen(argv[0]));
		write(1, " <arg0> [arg1, ...]\n", 20);
		return (0);
	}
	ft_init();
	fractol();
	return (0);
}
